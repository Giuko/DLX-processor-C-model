cpu_model/cpu_model.c:		cpu->IRAM[i] = NOP_Instruction;
cpu_model/cpu_model.c:	cpu->pc = -1;
cpu_model/cpu_model.c:    memset(cpu->regs, 0, sizeof(cpu->regs));
cpu_model/cpu_model.c:		cpu->IRAM[addr] = NOP_Instruction;
cpu_model/cpu_model.c:    	cpu->IRAM[addr] = instr;				// Or addr/4
cpu_model/cpu_model.c:	pipeFetch->instr = cpu->IRAM[cpu->pc];
cpu_model/cpu_model.c:	pipeFetch->nextPC = (cpu->pc+1)*4;
cpu_model/cpu_model.c:			rs1_val = cpu->regs[rs1];
cpu_model/cpu_model.c:			rs2_val = cpu->regs[rs2];
cpu_model/cpu_model.c:				rs1_val = cpu->regs[rs1];
cpu_model/cpu_model.c:				rs1_val = cpu->regs[rs1];
cpu_model/cpu_model.c:		rs1_val = cpu->regs[rs1];
cpu_model/cpu_model.c:				rs2_val = cpu->regs[rd];		// In case of a store, mem[rs1_val + offset] = rs2_val (R[rd]) 
cpu_model/cpu_model.c:		DRAM_out = cpu->DRAM[DRAM_addr];
cpu_model/cpu_model.c:		cpu->DRAM[DRAM_addr] = DRAM_data;
cpu_model/cpu_model.c:		printf("[MEM] JUMPING at 0x%08x\n", cpu->pc);
cpu_model/cpu_model.c:		pipeMem->nextPC = cpu->pc++;
cpu_model/cpu_model.c:	cpu->pc = pipeMem->nextPC; 
cpu_model/cpu_model.c:		cpu->regs[pipeMem->rd] = val_to_store;	
cpu_model/cpu_model.c:		cpu->pc++; // During normal operation is WB that will update the PC
cpu_model/cpu_model.c:    return cpu->regs[idx];
cpu_model/cpu_model.c:    return cpu->pc;
